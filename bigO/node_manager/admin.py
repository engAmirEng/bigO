from decimal import ROUND_HALF_DOWN, Decimal

import admin_extra_buttons.decorators
import admin_extra_buttons.mixins
import humanize.filesize
from django_json_widget.widgets import JSONEditorWidget
from render_block import render_block_to_string
from rest_framework_api_key.admin import APIKeyModelAdmin
from simple_history.admin import SimpleHistoryAdmin

from bigO.net_manager import models as net_manager_models
from bigO.proxy_manager import models as proxy_manager_models
from config.celery_app import app as celery_app
from django.conf import settings
from django.contrib import admin, messages
from django.contrib.auth.decorators import login_required
from django.contrib.humanize.templatetags.humanize import naturaltime
from django.db.models import Count, JSONField, Q, QuerySet
from django.http import HttpResponse
from django.shortcuts import get_object_or_404, render
from django.urls import reverse
from django.utils.html import format_html
from django.utils.translation import gettext

from . import forms, models, tasks


class NodeLatestSyncStatInline(admin.StackedInline):
    model = models.NodeLatestSyncStat
    form = forms.NodeLatestSyncStatModelForm


class NodePublicIPInline(admin.StackedInline):
    extra = 1
    model = models.NodePublicIP
    autocomplete_fields = ("ip",)


class NodeInnerProgramInline(admin.StackedInline):
    extra = 1
    model = models.NodeInnerProgram
    autocomplete_fields = ("program_version",)


@admin.register(models.ContainerSpec)
class ContainerSpecModelAdmin(admin.ModelAdmin):
    pass


@admin.register(models.NetplanConfiguration)
class NetplanConfigurationModelAdmin(admin.ModelAdmin):
    search_fields = ("name",)


class NodeSupervisorConfigInline(admin.StackedInline):
    model = models.NodeSupervisorConfig


class O2SpecInline(admin.StackedInline):
    model = models.O2Spec
    autocomplete_fields = ("program",)


@admin.register(models.Node)
class NodeModelAdmin(admin_extra_buttons.mixins.ExtraButtonsMixin, admin.ModelAdmin):
    list_display = (
        "node_display",
        "agent_spec_display",
        "downtime_attended",
        "last_sync_req_display",
        "last_sync_duration_display",
        "collect_metrics",
        "collect_logs",
        "public_ips_display",
        "view_supervisor_page_display",
    )
    list_editable = ["downtime_attended", "collect_metrics", "collect_logs"]
    search_fields = ("name", "node_nodepublicips__ip__ip")
    actions = ["do_deploy"]
    inlines = [
        NodePublicIPInline,
        O2SpecInline,
        NodeSupervisorConfigInline,
        NodeInnerProgramInline,
        NodeLatestSyncStatInline,
    ]
    autocomplete_fields = ("netplan_config", "default_cert", "ansible_deploy_snippet", "ssh_public_keys")

    @admin.action(description="Do Deploy")
    def do_deploy(self, request, queryset: QuerySet[models.Node]):
        invalid_queryset = queryset.filter(
            Q(
                Q(ssh_port__isnull=True)
                | Q(ssh_user__isnull=True)
                | Q(ssh_user="")
                | Q(ssh_pass__isnull=True)
                | Q(ansible_deploy_snippet__isnull=True)
                | Q(ssh_pass="")
                | Q(o2spec__isnull=True)
            )
        )
        if invalid_record_count := invalid_queryset.count():
            self.message_user(
                request,
                gettext("cannot be done becuase of {0} records").format(invalid_record_count),
                messages.ERROR,
            )
            return
        for i in queryset:
            ansible_deploy_node = tasks.ansible_deploy_node if settings.DEBUG else tasks.ansible_deploy_node.delay
            ansible_deploy_node(node_id=i.id)
        self.message_user(
            request,
            gettext("started for {0} records").format(queryset.count()),
            messages.INFO,
        )

    @admin_extra_buttons.decorators.view(
        pattern="<int:node_pk>/basic_supervisor/",
        decorators=[login_required(login_url="admin:login")],
        permission="node_manager.add_node",
    )
    def basic_supervisor(self, request, node_pk: int):
        node_obj = get_object_or_404(models.Node, pk=node_pk)
        connect_form = forms.SupervisorRPCConnectTypeForm(request.GET or request.POST, node_obj=node_obj)
        url = connect_form.get_url()
        connect_form = admin.helpers.AdminForm(
            form=connect_form,
            fieldsets=[(None, {"fields": (tuple(connect_form.fields),)})],
            prepopulated_fields={},
            model_admin=self,
        )
        iframe_url = None
        link_url = None
        if url is not None:
            iframe_url, link_url = url

        context = self.get_common_context(request, title="Basic Supervisor")
        context["node_id"] = node_pk
        context["connect_form"] = connect_form
        context["iframe_url"] = iframe_url
        context["link_url"] = link_url
        if request.htmx:
            r = render_block_to_string(
                "node_manager/admin/basic_supervisor.html", block_name="content", context=context, request=request
            )
            return HttpResponse(r)
        return render(request, "node_manager/admin/basic_supervisor.html", context=context)

    def get_queryset(self, request):
        qs = super().get_queryset(request)
        return qs.select_related("node_nodesyncstat", "supervisorconfig").ann_is_online().ann_generic_status()

    @admin.display(description="node display", ordering="is_revoked")
    def node_display(self, obj):
        return str(obj)

    @admin.display(description="public ips")
    def public_ips_display(self, obj):
        return ", ".join([i.mark + str(i.ip) for i in obj.node_nodepublicips.all()])

    @admin.display(ordering="node_nodesyncstat__initiated_at", description="last sync req")
    def last_sync_req_display(self, obj):
        nodesyncstat = getattr(obj, "node_nodesyncstat", None)
        match obj.generic_status:
            case models.GenericStatusChoices.ERROR:
                return f"üî¥ {naturaltime(nodesyncstat.initiated_at)}"
            case models.GenericStatusChoices.OFFLINE:
                return f"‚ö´Ô∏è {naturaltime(nodesyncstat.initiated_at)}"
            case models.GenericStatusChoices.ATTENDED_OFFLINE:
                return f"üîÑ {naturaltime(nodesyncstat.initiated_at)}"
            case models.GenericStatusChoices.NEVER:
                return "never"
            case models.GenericStatusChoices.ONLINE:
                return f"üü¢ {naturaltime(nodesyncstat.initiated_at)}"
            case _:
                raise NotImplementedError

    @admin.display(ordering="node_nodesyncstat__agent_spec", description="agent spec")
    def agent_spec_display(self, obj):
        nodesyncstat = getattr(obj, "node_nodesyncstat", None)
        if nodesyncstat is None:
            return None
        return nodesyncstat.agent_spec

    @admin.display(description="last sync duration")
    def last_sync_duration_display(self, obj):
        nodesyncstat = getattr(obj, "node_nodesyncstat", None)
        if nodesyncstat is None:
            return "never"
        if nodesyncstat.respond_at is None:
            return "not responded"
        microseconds = (nodesyncstat.respond_at - nodesyncstat.initiated_at).microseconds
        return Decimal(microseconds / 1000000).quantize(Decimal("0.01"), rounding=ROUND_HALF_DOWN)

    @admin.display(description="view supervisor page")
    def view_supervisor_page_display(self, obj):
        supervisorconfig = getattr(obj, "supervisorconfig", None)
        if supervisorconfig is None or not supervisorconfig.xml_rpc_api_expose_port:
            return None
        return format_html(
            '<a href="{}" target="_blank">View Supervisor</a>',
            reverse("admin:node_manager_node_basic_supervisor", kwargs={"node_pk": obj.id}),
        )


@admin.register(models.NodePublicIP)
class NodePublicIPModelAdmin(admin.ModelAdmin):
    list_display = ("pk", "node", "ip")
    search_fields = ("node__name", "ip__ip")


class AnsibleTaskNodeInline(admin.StackedInline):
    model = models.AnsibleTaskNode
    extra = 0
    formfield_overrides = {
        JSONField: {"widget": JSONEditorWidget(mode="view")},
    }


@admin.register(models.AnsibleTask)
class AnsibleTaskModelAdmin(admin.ModelAdmin):
    list_display = ("__str__", "name", "status", "ok", "dark", "changed", "failures", "created_at", "finished_at")
    actions = ["revoke_with_terminate"]
    inlines = [AnsibleTaskNodeInline]
    formfield_overrides = {
        JSONField: {"widget": JSONEditorWidget(mode="view")},
    }

    def get_queryset(self, request):
        return super().get_queryset(request).ann_stats()

    @admin.action()
    def revoke_with_terminate(self, request, queryset: QuerySet[models.AnsibleTask]):
        celery_app.control.revoke([i.celery_task_id for i in queryset], terminate=True)
        self.message_user(
            request,
            gettext("terminated for {0} records").format(queryset.count()),
            messages.INFO,
        )


@admin.register(models.NodeAPIKey)
class NodeAPIKeyModelAdmin(APIKeyModelAdmin):
    pass


class RealitySpecForIPInline(admin.StackedInline):
    model = proxy_manager_models.RealitySpec
    extra = 0
    autocomplete_fields = ("dest_ip",)
    fk_name = "for_ip"
    verbose_name = "ForIP RealitySpecs"


class DNSRecordIPValueInline(admin.StackedInline):
    model = net_manager_models.DNSRecord
    extra = 0
    verbose_name = "IP Value DNS Record"
    show_change_link = True


@admin.register(models.PublicIP)
class PublicIPModelAdmin(admin.ModelAdmin):
    list_display = ("__str__", "asn", "node_display")
    search_fields = ("name", "ip")
    inlines = (
        RealitySpecForIPInline,
        DNSRecordIPValueInline,
    )

    @admin.display(ordering="node_id", description="node")
    def node_display(self, obj):
        return obj.node_name


class ProgramVersionInline(admin.StackedInline):
    extra = 1
    model = models.ProgramVersion


@admin.register(models.Snippet)
class SnippetModelAdmin(SimpleHistoryAdmin, admin.ModelAdmin):
    search_fields = ("name", "template")


@admin.register(models.Program)
class ProgramModelAdmin(admin.ModelAdmin):
    inlines = [ProgramVersionInline]
    search_fields = ("name",)


@admin.register(models.ProgramVersion)
class ProgramVersionModelAdmin(admin.ModelAdmin):
    autocomplete_fields = ("program",)
    search_fields = ("program__name", "version")


@admin.register(models.SupervisorProcessInfo)
class SupervisorProcessInfoModelAdmin(admin.ModelAdmin):
    ordering = ("node", "name")
    list_display = (
        "id",
        "node",
        "name",
        "last_changed_at_display",
        "description",
        "statename_display",
        "last_captured_at_display",
    )
    list_filter = ("node", "name", "last_state")
    search_fields = ("name",)
    autocomplete_fields = ("node",)

    @admin.display(ordering="last_statename", description="statename")
    def statename_display(self, obj: models.SupervisorProcessInfo):
        perv_fortime = obj.perv_captured_at - obj.perv_changed_at
        last_fortime = obj.last_captured_at - obj.last_changed_at
        perv_fortime_str = ""
        if perv_fortime:
            perv_fortime_str = str(perv_fortime)
        last_fortime_str = ""
        if last_fortime:
            last_fortime_str = str(last_fortime)
        return f"{obj.perv_statename}({perv_fortime_str}) -> {obj.last_statename}({last_fortime_str})"

    @admin.display(ordering="last_changed_at", description="last changed at")
    def last_changed_at_display(self, obj: models.SupervisorProcessInfo):
        return naturaltime(obj.last_changed_at)

    @admin.display(ordering="last_captured_at", description="last captured at")
    def last_captured_at_display(self, obj: models.SupervisorProcessInfo):
        return naturaltime(obj.last_captured_at)


class NodeCustomConfigInline(admin.StackedInline):
    extra = 1
    model = models.NodeCustomConfig
    autocomplete_fields = ("node",)


class CustomConfigDependantFileInline(admin.StackedInline):
    extra = 1
    model = models.CustomConfigDependantFile
    show_change_link = True
    autocomplete_fields = ("file",)


@admin.register(models.CustomConfig)
class CustomConfigModelAdmin(SimpleHistoryAdmin, admin.ModelAdmin):
    list_display = ("__str__", "used_by_count")
    list_filter = ("nodecustomconfigs__node",)
    search_fields = (
        "name",
        "program_version__program__name",
        "program_version__version",
        "run_opts_template",
        "dependantfiles__key",
        "dependantfiles__template",
        "dependantfiles__file__program__name",
        "dependantfiles__file__version",
    )
    inlines = [CustomConfigDependantFileInline, NodeCustomConfigInline]

    def get_queryset(self, request):
        qs = super().get_queryset(request)
        return qs.annotate(used_by_count=Count("nodecustomconfigs"))

    @admin.display(ordering="used_by_count")
    def used_by_count(self, obj):
        return obj.used_by_count


@admin.register(models.CustomConfigDependantFile)
class CustomConfigDependantFileModelAdmin(SimpleHistoryAdmin, admin.ModelAdmin):
    pass


@admin.register(models.EasyTierNetwork)
class EasyTierNetworkModelAdmin(admin.ModelAdmin):
    list_display = ("__str__", "program_version", "ip_range")
    list_select_related = ("program_version",)


@admin.register(models.EasyTierNodeListener)
class EasyTierNodeListenerModelAdmin(admin.ModelAdmin):
    list_display = ("__str__", "node__node", "node__network", "protocol", "port")
    list_select_related = ("node",)
    search_fields = ("node__node__name", "node__node__node_nodepublicips__ip__ip")


class EasyTierNodeListenerInline(admin.StackedInline):
    extra = 1
    model = models.EasyTierNodeListener


class EasyTierNodePeerInline(admin.StackedInline):
    extra = 1
    model = models.EasyTierNodePeer
    fk_name = models.EasyTierNodePeer.node.field.name
    autocomplete_fields = ("peer_listener", "peer_public_ip")


@admin.register(models.EasyTierNode)
class EasyTierNodeModelAdmin(admin.ModelAdmin):
    form = forms.EasyTierNodeModelForm
    inlines = [EasyTierNodePeerInline, EasyTierNodeListenerInline]
    list_display = ("__str__", "network_display", "preferred_program_version", "ipv4", "latency_first")
    list_editable = ("latency_first", "preferred_program_version")
    autocomplete_fields = ("preferred_program_version", "node")
    list_filter = ("network", "node")
    list_select_related = ("network",)

    @admin.display(ordering="network", description="Network")
    def network_display(self, obj):
        url = reverse(
            f"admin:{obj.network._meta.app_label}_{obj.network._meta.model_name}_change", args=(obj.network.pk,)
        )
        return format_html('<a href="{}">{}</a>', url, str(obj.network))

    @admin.display()
    def toml_config_display(self, obj):
        return obj.get_toml_config_content()


@admin.register(models.ProgramBinary)
class ProgramBinaryModelAdmin(admin.ModelAdmin):
    form = forms.ProgramBinaryModelForm
    readonly_fields = ["hash"]
    autocomplete_fields = ("program_version",)
    list_display = ("__str__", "file_size_display")
    search_fields = ("hash", "program_version__program__name")

    @admin.display(description="file size")
    def file_size_display(self, obj: models.ProgramBinary):
        try:
            return humanize.filesize.naturalsize(obj.file.size)
        except FileNotFoundError as e:
            return str(e)

    def save_model(self, request, obj, form, change):
        if file_hash := form.cleaned_data.get("file_hash"):
            obj.hash = file_hash
        super().save_model(request, obj, form, change)


@admin.register(models.NodeInnerProgram)
class NodeInnerProgramModelAdmin(admin.ModelAdmin):
    pass


@admin.register(models.NodeLatestSyncStat)
class NodeLatestSyncStatModelAdmin(admin.ModelAdmin):
    pass
